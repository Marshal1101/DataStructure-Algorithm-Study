# https://www.acmicpc.net/board/view/107115
def find(start, end) :
    global K
    
    if start == end : return
    # -> 배열의 원소의 개수가 1이면 정렬 진행하지 않음
    
    mid = (start+end)//2
    find(start, mid)
    find(mid+1, end)
    # -> 원소 수가 적은 배열부터 정렬하므로 배열의 원소를 둘로 나눈 것부터 정렬 진행
    
    if K <=end-start+1 : 
    # -> K번째에 원소를 넣는 배열인지 확인 (정렬하려는 배열의 크기 >= K인지 확인)
        J = sorted(I[start:end+1])
        # -> 우리가 원하는 배열만 정렬
        
        print(J[K-1])
        exit()
        # -> A에 몇번째 들어가는지 확인 후 정렬된 배열에서 그 수 출력, 프로그램 종료
    
    K -= end-start+1 
    # -> 정렬하려는 배열의 크기 < K면 우리가 원하는 배열이 아니므로 A에 원소가 들어간 만큼 K에서 빼줌 

N, K = map(int,input().split())
I = list(map(int,input().split()))
find(0, N-1)
print(-1) # -> 만약 이 과정을 진행했는데 프로그램이 종료되지 않았다면 저장 횟수가 K보다 작은 것이므로 -1 출력


"""
cinador   1달 전    4좋아요 취소
음... 제 코드에서 변수명만 줄여서 숏코딩 노리고 제출하신거라... 제가 대신 설명해드리겠습니다.

병합정렬은 정렬된 두 배열을 다시 합쳐서 정렬하는 방식입니다. 예제 1번을 예로 들면

(4, 5, 1, 3, 2)을 (4, 5, 1), (3, 2)로 분리
-> (4, 5, 1)을 (4, 5), (1)로 분리
-> (4, 5)를 (4, 5)로 정렬
-> (1)은 정렬 할 필요 없으므로 (4, 5, 1)을 (1, 4, 5)로 정렬

다음으로 (3, 2)를 (2, 3)으로 정렬
-> (1, 4, 5), (2, 3)을 합쳐서 (1, 2, 3, 4, 5)로 정렬 이런 과정을 거칩니다.

여기서 예제의 설명을 보시면 아시겠지만 정렬 과정에서 A에는 정렬하려는 배열의 작은 원소 순으로 들어갑니다.
((4, 5, 1) 정렬 과정에는 A에 1, 4, 5 가 차례대로 들어감)

그리고 어떤 배열을 정렬할 때 A에 들어가는 원소의 개수는 그 배열의 원소의 개수와 같습니다.
(배열의 원소의 개수가 1이면 정렬을 진행하지 않으므로 예외)

이 문제는 A에 K번째 저장되는 수를 물어보고 있습니다.
그렇다면 K번째 저장될 때 정렬이 진행되고 있는 배열만 구하고, 그 배열에서 A에 몇번째로 들어가는지만 알면 됩니다.

이 때문에 실제 병합정렬을 진행하면서 문제를 풀지 않아도 됩니다.
정렬을 하지 않다가 우리가 원하는 배열 구하고 그 배열만 정렬해주면 됩니다.

정렬을 진행한 두 배열을 다시 정렬해주는 것이고,
정렬 과정에서 그 배열의 작은 원소순으로 A에 들어가는 것이기 때문에 실제 문제를 풀기 위한 정렬은 마지막 한번만으로 충분합니다.

아래에 제가 제출한 코드로 위 내용을 정리해드립니다.

"""